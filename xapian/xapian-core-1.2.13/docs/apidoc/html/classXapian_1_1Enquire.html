<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: xapian-core: Xapian::Enquire Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceXapian.html">Xapian</a>::<a class="el" href="classXapian_1_1Enquire.html">Enquire</a>
  </div>
</div>
<div class="contents">
<h1>Xapian::Enquire Class Reference</h1><!-- doxytag: class="Xapian::Enquire" -->This class provides an interface to the information retrieval system for the purpose of searching.  
<a href="#_details">More...</a>
<p>

<p>
<a href="classXapian_1_1Enquire-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c451dc68045ec4b0d26f5b2a42eae2a9"></a><!-- doxytag: member="Xapian::Enquire::Enquire" ref="c451dc68045ec4b0d26f5b2a42eae2a9" args="(const Enquire &amp;other)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#c451dc68045ec4b0d26f5b2a42eae2a9">Enquire</a> (const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copying is allowed (and is cheap). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c067ef5b6397ab064d09884efc06cbe"></a><!-- doxytag: member="Xapian::Enquire::operator=" ref="0c067ef5b6397ab064d09884efc06cbe" args="(const Enquire &amp;other)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#0c067ef5b6397ab064d09884efc06cbe">operator=</a> (const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment is allowed (and is cheap). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#f9dcba0c6d10dd8dd6ae59e087f84799">Enquire</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;database, <a class="el" href="classXapian_1_1ErrorHandler.html">ErrorHandler</a> *errorhandler_=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object.  <a href="#f9dcba0c6d10dd8dd6ae59e087f84799"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="808479faae76453f34a24881805e75b9"></a><!-- doxytag: member="Xapian::Enquire::~Enquire" ref="808479faae76453f34a24881805e75b9" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#808479faae76453f34a24881805e75b9">~Enquire</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#1148d960120662e5543e2a2b12620318">set_query</a> (const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;query, <a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> qlen=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the query to run.  <a href="#1148d960120662e5543e2a2b12620318"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#dd445bf19315638cccbb6418e2ae0d42">get_query</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the query which has been set.  <a href="#dd445bf19315638cccbb6418e2ae0d42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#43b54489c53d26a98d3fde3f1d3aa14f">add_matchspy</a> (<a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a> *spy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a matchspy.  <a href="#43b54489c53d26a98d3fde3f1d3aa14f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1bb73406e3e7749a9e66ebc96ebd13f3"></a><!-- doxytag: member="Xapian::Enquire::clear_matchspies" ref="1bb73406e3e7749a9e66ebc96ebd13f3" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#1bb73406e3e7749a9e66ebc96ebd13f3">clear_matchspies</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all the matchspies. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#d5c72e6f34c5c2da5f0b8c79736704ab">set_weighting_scheme</a> (const <a class="el" href="classXapian_1_1Weight.html">Weight</a> &amp;weight_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the weighting scheme to use for queries.  <a href="#d5c72e6f34c5c2da5f0b8c79736704ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#117ee547f5908e952e2e72d5a986d3bb">set_collapse_key</a> (<a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> collapse_key, <a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> collapse_max=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the collapse key to use for queries.  <a href="#117ee547f5908e952e2e72d5a986d3bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#bbf7ff734ff6adcb301e493f6eed803b">set_docid_order</a> (docid_order order)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the direction in which documents are ordered by document id in the returned <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>.  <a href="#bbf7ff734ff6adcb301e493f6eed803b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#dadaa8401e40ab4cec090bc1541a11b7">set_cutoff</a> (<a class="el" href="namespaceXapian.html#22ea0a80c58a2047dd929621b75ed9a2">Xapian::percent</a> percent_cutoff, <a class="el" href="namespaceXapian.html#cac12803afc9e24ee5141c119acb8884">Xapian::weight</a> weight_cutoff=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the percentage and/or weight cutoffs.  <a href="#dadaa8401e40ab4cec090bc1541a11b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#80a33a28791c05167204706c1a9d986b">set_sort_by_relevance</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by relevance only.  <a href="#80a33a28791c05167204706c1a9d986b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#b10384fabd51eebd8174f916563e3f7a">set_sort_by_value</a> (<a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> sort_key, bool reverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by value only.  <a href="#b10384fabd51eebd8174f916563e3f7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#0bcb7086d8633fc035c6e5d094e45d39">set_sort_by_key</a> (<a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *sorter, bool reverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by key generated from values only.  <a href="#0bcb7086d8633fc035c6e5d094e45d39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a921b3c9386fbe2ddfd7dbbf130f9391">set_sort_by_value_then_relevance</a> (<a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> sort_key, bool reverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by value, then by relevance for documents with the same value.  <a href="#a921b3c9386fbe2ddfd7dbbf130f9391"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#562beac4843f310dbdc61fdd33209be4">set_sort_by_key_then_relevance</a> (<a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *sorter, bool reverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by keys generated from values, then by relevance for documents with identical keys.  <a href="#562beac4843f310dbdc61fdd33209be4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#5a495760d5edc479385b14b463affbff">set_sort_by_relevance_then_value</a> (<a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> sort_key, bool reverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by relevance then value.  <a href="#5a495760d5edc479385b14b463affbff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#c64b07e06a24519baf1c495d0edcd0c3">set_sort_by_relevance_then_key</a> (<a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *sorter, bool reverse)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the sorting to be by relevance, then by keys generated from values.  <a href="#c64b07e06a24519baf1c495d0edcd0c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#c04aa26eff82db9fd810b8125a31ee55">get_eset</a> (<a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, int flags=0, double k=1.0, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#c04aa26eff82db9fd810b8125a31ee55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#f73e3672a3f1077309fbc99ef2db5412">get_eset</a> (<a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#f73e3672a3f1077309fbc99ef2db5412"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a0b50863720f25f8a026bee73913798b">get_eset</a> (<a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, int flags, double k, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider, <a class="el" href="namespaceXapian.html#cac12803afc9e24ee5141c119acb8884">Xapian::weight</a> min_wt) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#a0b50863720f25f8a026bee73913798b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#dda4181ccd15beb52c39f5e24adbb25b">get_matching_terms_begin</a> (<a class="el" href="namespaceXapian.html#8fa9094bebe1256a7be935a5ede87a64">Xapian::docid</a> did) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get terms which match a given document, by document id.  <a href="#dda4181ccd15beb52c39f5e24adbb25b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a27b926405ef71ab138fa656dab0bd4"></a><!-- doxytag: member="Xapian::Enquire::get_matching_terms_end" ref="6a27b926405ef71ab138fa656dab0bd4" args="(Xapian::docid) const " -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#6a27b926405ef71ab138fa656dab0bd4">get_matching_terms_end</a> (<a class="el" href="namespaceXapian.html#8fa9094bebe1256a7be935a5ede87a64">Xapian::docid</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#dda4181ccd15beb52c39f5e24adbb25b" title="Get terms which match a given document, by document id.">get_matching_terms_begin()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#4d531a494be857ae09c831480ff651d7">get_matching_terms_begin</a> (const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;it) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get terms which match a given document, by match set item.  <a href="#4d531a494be857ae09c831480ff651d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="619e5a4f3597ed800e8f11190a5b7fe0"></a><!-- doxytag: member="Xapian::Enquire::get_matching_terms_end" ref="619e5a4f3597ed800e8f11190a5b7fe0" args="(const MSetIterator &amp;) const " -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#619e5a4f3597ed800e8f11190a5b7fe0">get_matching_terms_end</a> (const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#dda4181ccd15beb52c39f5e24adbb25b" title="Get terms which match a given document, by document id.">get_matching_terms_begin()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a980eb2599afdf52ae78788849c9921"></a><!-- doxytag: member="Xapian::Enquire::get_description" ref="4a980eb2599afdf52ae78788849c9921" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#4a980eb2599afdf52ae78788849c9921">get_description</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing this object. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1MSet.html">MSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#edb5fb761acc0bb2249bec375883a093">get_mset</a> (<a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> maxitems, <a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> checkatleast=0, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset=0, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get (a portion of) the match set for the current query.  <a href="#edb5fb761acc0bb2249bec375883a093"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1MSet.html">MSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#1fc149dc9c58bc962ce9e4372c863185">get_mset</a> (<a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> maxitems, <a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> checkatleast, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *matchspy) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get (a portion of) the match set for the current query.  <a href="#1fc149dc9c58bc962ce9e4372c863185"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1MSet.html">MSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#d53aba9cb5b62d14dce5395f568c050f">get_mset</a> (<a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get (a portion of) the match set for the current query.  <a href="#d53aba9cb5b62d14dce5395f568c050f"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class provides an interface to the information retrieval system for the purpose of searching. 
<p>
Databases are usually opened lazily, so exceptions may not be thrown where you would expect them to be. You should catch <a class="el" href="classXapian_1_1Error.html" title="All exceptions thrown by Xapian are subclasses of Xapian::Error.">Xapian::Error</a> exceptions when calling any method in <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a>.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>will be thrown if an invalid argument is supplied, for example, an unknown database type. </td></tr>
  </table>
</dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="f9dcba0c6d10dd8dd6ae59e087f84799"></a><!-- doxytag: member="Xapian::Enquire::Enquire" ref="f9dcba0c6d10dd8dd6ae59e087f84799" args="(const Database &amp;database, ErrorHandler *errorhandler_=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Enquire::Enquire           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXapian_1_1ErrorHandler.html">ErrorHandler</a> *&nbsp;</td>
          <td class="paramname"> <em>errorhandler_</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object. 
<p>
This specification cannot be changed once the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> is opened: you must create a new <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object to access a different database, or set of databases.<p>
The database supplied must have been initialised (ie, must not be the result of calling the <a class="el" href="classXapian_1_1Database.html#24f8197f3ac8bfd8c2526e0b8dff4ff7" title="Create a Database with no databases in.">Database::Database()</a> constructor). If you need to handle a situation where you have no index gracefully, a database created with <a class="el" href="namespaceXapian_1_1InMemory.html#b4b5fcea687b7b2eb81c5ecc58673d72" title="Construct a WritableDatabase object for a new, empty InMemory database.">InMemory::open()</a> can be passed here, which represents a completely empty database.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>database</em>&nbsp;</td><td>Specification of the database or databases to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorhandler_</em>&nbsp;</td><td>A pointer to the error handler to use. Ownership of the object pointed to is not assumed by the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object - the user should delete the <a class="el" href="classXapian_1_1ErrorHandler.html" title="Decide if a Xapian::Error exception should be ignored.">Xapian::ErrorHandler</a> object after the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Xapian::Enquire</a> object is deleted. To use no error handler, this parameter should be 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>will be thrown if an empty <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases.">Database</a> object is supplied. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="43b54489c53d26a98d3fde3f1d3aa14f"></a><!-- doxytag: member="Xapian::Enquire::add_matchspy" ref="43b54489c53d26a98d3fde3f1d3aa14f" args="(MatchSpy *spy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::add_matchspy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a> *&nbsp;</td>
          <td class="paramname"> <em>spy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a matchspy. 
<p>
This matchspy will be called with some of the documents which match the query, during the match process. Exactly which of the matching documents are passed to it depends on exactly when certain optimisations occur during the match process, but it can be controlled to some extent by setting the <em>checkatleast</em> parameter to <em><a class="el" href="classXapian_1_1Enquire.html#edb5fb761acc0bb2249bec375883a093" title="Get (a portion of) the match set for the current query.">get_mset()</a></em>.<p>
In particular, if there are enough matching documents, at least the number specified by <em>checkatleast</em> will be passed to the matchspy. This means that you can force the matchspy to be shown all matching documents by setting <em>checkatleast</em> to the number of documents in the database.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spy</em>&nbsp;</td><td>The <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies.">MatchSpy</a> subclass to add. The caller must ensure that this remains valid while the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose...">Enquire</a> object remains active, or until <em><a class="el" href="classXapian_1_1Enquire.html#1bb73406e3e7749a9e66ebc96ebd13f3" title="Remove all the matchspies.">clear_matchspies()</a></em> is called. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a0b50863720f25f8a026bee73913798b"></a><!-- doxytag: member="Xapian::Enquire::get_eset" ref="a0b50863720f25f8a026bee73913798b" args="(Xapian::termcount maxitems, const RSet &amp;omrset, int flags, double k, const Xapian::ExpandDecider *edecider, Xapian::weight min_wt) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>edecider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#cac12803afc9e24ee5141c119acb8884">Xapian::weight</a>&nbsp;</td>
          <td class="paramname"> <em>min_wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the expand set for the given rset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxitems</em>&nbsp;</td><td>the maximum number of items to return. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>omrset</em>&nbsp;</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>zero or more of these values |-ed together:<ul>
<li>Xapian::Enquire::INCLUDE_QUERY_TERMS query terms may be returned from expand</li><li>Xapian::Enquire::USE_EXACT_TERMFREQ for multi dbs, calculate the exact termfreq; otherwise an approximation is used which can greatly improve efficiency, but still returns good results. </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>the parameter k in the query expansion algorithm (default is 1.0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edecider</em>&nbsp;</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>min_wt</em>&nbsp;</td><td>the minimum weight for included terms</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a> object containing the results of the expand.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>See class documentation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f73e3672a3f1077309fbc99ef2db5412"></a><!-- doxytag: member="Xapian::Enquire::get_eset" ref="f73e3672a3f1077309fbc99ef2db5412" args="(Xapian::termcount maxitems, const RSet &amp;omrset, const Xapian::ExpandDecider *edecider) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>edecider</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the expand set for the given rset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxitems</em>&nbsp;</td><td>the maximum number of items to return. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>omrset</em>&nbsp;</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edecider</em>&nbsp;</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a> object containing the results of the expand.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>See class documentation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c04aa26eff82db9fd810b8125a31ee55"></a><!-- doxytag: member="Xapian::Enquire::get_eset" ref="c04aa26eff82db9fd810b8125a31ee55" args="(Xapian::termcount maxitems, const RSet &amp;omrset, int flags=0, double k=1.0, const Xapian::ExpandDecider *edecider=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>k</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>edecider</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the expand set for the given rset. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxitems</em>&nbsp;</td><td>the maximum number of items to return. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>omrset</em>&nbsp;</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>zero or more of these values |-ed together:<ul>
<li>Xapian::Enquire::INCLUDE_QUERY_TERMS query terms may be returned from expand</li><li>Xapian::Enquire::USE_EXACT_TERMFREQ for multi dbs, calculate the exact termfreq; otherwise an approximation is used which can greatly improve efficiency, but still returns good results. </li></ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>the parameter k in the query expansion algorithm (default is 1.0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edecider</em>&nbsp;</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet).">ESet</a> object containing the results of the expand.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>See class documentation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4d531a494be857ae09c831480ff651d7"></a><!-- doxytag: member="Xapian::Enquire::get_matching_terms_begin" ref="4d531a494be857ae09c831480ff651d7" args="(const MSetIterator &amp;it) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_begin           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>it</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get terms which match a given document, by match set item. 
<p>
This method returns the terms in the current query which match the given document.<p>
If the underlying database has suitable support, using this call (rather than passing a <a class="el" href="namespaceXapian.html#8fa9094bebe1256a7be935a5ede87a64" title="A unique identifier for a document.">Xapian::docid</a>) will enable the system to ensure that the correct data is returned, and that the document has not been deleted or changed since the query was performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>The iterator for which to retrieve the matching terms.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator returning the terms which match the document. The terms will be returned (as far as this makes any sense) in the same order as the terms in the query. Terms will not occur more than once, even if they do in the query.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>See class documentation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1DocNotFoundError.html" title="Indicates an attempt to access a document not present in the database.">Xapian::DocNotFoundError</a></em>&nbsp;</td><td>The document specified could not be found in the database. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dda4181ccd15beb52c39f5e24adbb25b"></a><!-- doxytag: member="Xapian::Enquire::get_matching_terms_begin" ref="dda4181ccd15beb52c39f5e24adbb25b" args="(Xapian::docid did) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_begin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#8fa9094bebe1256a7be935a5ede87a64">Xapian::docid</a>&nbsp;</td>
          <td class="paramname"> <em>did</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get terms which match a given document, by document id. 
<p>
This method returns the terms in the current query which match the given document.<p>
It is possible for the document to have been removed from the database between the time it is returned in an <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>, and the time that this call is made. If possible, you should specify an <a class="el" href="classXapian_1_1MSetIterator.html" title="An iterator pointing to items in an MSet.">MSetIterator</a> instead of a <a class="el" href="namespaceXapian.html#8fa9094bebe1256a7be935a5ede87a64" title="A unique identifier for a document.">Xapian::docid</a>, since this will enable database backends with suitable support to prevent this occurring.<p>
Note that a query does not need to have been run in order to make this call.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>did</em>&nbsp;</td><td>The document id for which to retrieve the matching terms.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator returning the terms which match the document. The terms will be returned (as far as this makes any sense) in the same order as the terms in the query. Terms will not occur more than once, even if they do in the query.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>See class documentation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1DocNotFoundError.html" title="Indicates an attempt to access a document not present in the database.">Xapian::DocNotFoundError</a></em>&nbsp;</td><td>The document specified could not be found in the database. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d53aba9cb5b62d14dce5395f568c050f"></a><!-- doxytag: member="Xapian::Enquire::get_mset" ref="d53aba9cb5b62d14dce5395f568c050f" args="(Xapian::doccount first, Xapian::doccount maxitems, const RSet *omrset, const MatchDecider *mdecider=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1MSet.html">MSet</a> Xapian::Enquire::get_mset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *&nbsp;</td>
          <td class="paramname"> <em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>mdecider</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get (a portion of) the match set for the current query. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>the first item in the result set to return. A value of zero corresponds to the first item returned being that with the highest score. A value of 10 corresponds to the first 10 items being ignored, and the returned items starting at the eleventh. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxitems</em>&nbsp;</td><td>the maximum number of items to return. If you want all matches, then you can pass the result of calling get_doccount() on the <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases.">Database</a> object (though if you are doing this so you can filter results, you are likely to get much better performance by using Xapian's match-time filtering features instead). You can pass 0 for maxitems which will give you an empty <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a> with valid statistics (such as get_matches_estimated()) calculated without looking at any postings, which is very quick, but means the estimates may be more approximate and the bounds may be much looser. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>checkatleast</em>&nbsp;</td><td>the minimum number of items to check. Because the matcher optimises, it won't consider every document which might match, so the total number of matches is estimated. Setting checkatleast forces it to consider at least this many matches and so allows for reliable paging links. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>omrset</em>&nbsp;</td><td>the relevance set to use when performing the query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mdecider</em>&nbsp;</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matchspy</em>&nbsp;</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. The matchspy is applied to every document which is a potential candidate for the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>, so if there are checkatleast or more such documents, the matchspy will see at least checkatleast. The mdecider is assumed to be a relatively expensive test so may be applied in a lazier fashion.</td></tr>
  </table>
</dl>
<dl class="deprecated" compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>this parameter is deprecated - use the newer <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies.">MatchSpy</a> class and <a class="el" href="classXapian_1_1Enquire.html#43b54489c53d26a98d3fde3f1d3aa14f" title="Add a matchspy.">add_matchspy()</a> method instead.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">Xapian::MSet</a> object containing the results of the query.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>See class documentation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1fc149dc9c58bc962ce9e4372c863185"></a><!-- doxytag: member="Xapian::Enquire::get_mset" ref="1fc149dc9c58bc962ce9e4372c863185" args="(Xapian::doccount first, Xapian::doccount maxitems, Xapian::doccount checkatleast, const RSet *omrset, const MatchDecider *mdecider, const MatchDecider *matchspy) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1MSet.html">MSet</a> Xapian::Enquire::get_mset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>checkatleast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *&nbsp;</td>
          <td class="paramname"> <em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>mdecider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>matchspy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get (a portion of) the match set for the current query. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>the first item in the result set to return. A value of zero corresponds to the first item returned being that with the highest score. A value of 10 corresponds to the first 10 items being ignored, and the returned items starting at the eleventh. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxitems</em>&nbsp;</td><td>the maximum number of items to return. If you want all matches, then you can pass the result of calling get_doccount() on the <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases.">Database</a> object (though if you are doing this so you can filter results, you are likely to get much better performance by using Xapian's match-time filtering features instead). You can pass 0 for maxitems which will give you an empty <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a> with valid statistics (such as get_matches_estimated()) calculated without looking at any postings, which is very quick, but means the estimates may be more approximate and the bounds may be much looser. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>checkatleast</em>&nbsp;</td><td>the minimum number of items to check. Because the matcher optimises, it won't consider every document which might match, so the total number of matches is estimated. Setting checkatleast forces it to consider at least this many matches and so allows for reliable paging links. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>omrset</em>&nbsp;</td><td>the relevance set to use when performing the query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mdecider</em>&nbsp;</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matchspy</em>&nbsp;</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. The matchspy is applied to every document which is a potential candidate for the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>, so if there are checkatleast or more such documents, the matchspy will see at least checkatleast. The mdecider is assumed to be a relatively expensive test so may be applied in a lazier fashion.</td></tr>
  </table>
</dl>
<dl class="deprecated" compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>this parameter is deprecated - use the newer <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies.">MatchSpy</a> class and <a class="el" href="classXapian_1_1Enquire.html#43b54489c53d26a98d3fde3f1d3aa14f" title="Add a matchspy.">add_matchspy()</a> method instead.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">Xapian::MSet</a> object containing the results of the query.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>See class documentation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="edb5fb761acc0bb2249bec375883a093"></a><!-- doxytag: member="Xapian::Enquire::get_mset" ref="edb5fb761acc0bb2249bec375883a093" args="(Xapian::doccount first, Xapian::doccount maxitems, Xapian::doccount checkatleast=0, const RSet *omrset=0, const MatchDecider *mdecider=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1MSet.html">MSet</a> Xapian::Enquire::get_mset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>checkatleast</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *&nbsp;</td>
          <td class="paramname"> <em>omrset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&nbsp;</td>
          <td class="paramname"> <em>mdecider</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get (a portion of) the match set for the current query. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>the first item in the result set to return. A value of zero corresponds to the first item returned being that with the highest score. A value of 10 corresponds to the first 10 items being ignored, and the returned items starting at the eleventh. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxitems</em>&nbsp;</td><td>the maximum number of items to return. If you want all matches, then you can pass the result of calling get_doccount() on the <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases.">Database</a> object (though if you are doing this so you can filter results, you are likely to get much better performance by using Xapian's match-time filtering features instead). You can pass 0 for maxitems which will give you an empty <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a> with valid statistics (such as get_matches_estimated()) calculated without looking at any postings, which is very quick, but means the estimates may be more approximate and the bounds may be much looser. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>checkatleast</em>&nbsp;</td><td>the minimum number of items to check. Because the matcher optimises, it won't consider every document which might match, so the total number of matches is estimated. Setting checkatleast forces it to consider at least this many matches and so allows for reliable paging links. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>omrset</em>&nbsp;</td><td>the relevance set to use when performing the query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mdecider</em>&nbsp;</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>matchspy</em>&nbsp;</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. The matchspy is applied to every document which is a potential candidate for the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>, so if there are checkatleast or more such documents, the matchspy will see at least checkatleast. The mdecider is assumed to be a relatively expensive test so may be applied in a lazier fashion.</td></tr>
  </table>
</dl>
<dl class="deprecated" compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>this parameter is deprecated - use the newer <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies.">MatchSpy</a> class and <a class="el" href="classXapian_1_1Enquire.html#43b54489c53d26a98d3fde3f1d3aa14f" title="Add a matchspy.">add_matchspy()</a> method instead.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">Xapian::MSet</a> object containing the results of the query.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>See class documentation. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="dd445bf19315638cccbb6418e2ae0d42"></a><!-- doxytag: member="Xapian::Enquire::get_query" ref="dd445bf19315638cccbb6418e2ae0d42" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a>&amp; Xapian::Enquire::get_query           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the query which has been set. 
<p>
This is only valid after <a class="el" href="classXapian_1_1Enquire.html#1148d960120662e5543e2a2b12620318" title="Set the query to run.">set_query()</a> has been called.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></em>&nbsp;</td><td>will be thrown if query has not yet been set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="117ee547f5908e952e2e72d5a986d3bb"></a><!-- doxytag: member="Xapian::Enquire::set_collapse_key" ref="117ee547f5908e952e2e72d5a986d3bb" args="(Xapian::valueno collapse_key, Xapian::doccount collapse_max=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_collapse_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>collapse_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&nbsp;</td>
          <td class="paramname"> <em>collapse_max</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the collapse key to use for queries. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collapse_key</em>&nbsp;</td><td>value number to collapse on - at most one <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a> entry with each particular value will be returned (default is <a class="el" href="namespaceXapian.html#0a75ef120e641c77f703e60f595ffda2" title="Reserved value to indicate &quot;no valueno&quot;.">Xapian::BAD_VALUENO</a> which means no collapsing).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>collapse_max</em>&nbsp;</td><td>Max number of items with the same key to leave after collapsing (default 1).</td></tr>
  </table>
</dl>
The <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a> returned by <a class="el" href="classXapian_1_1Enquire.html#edb5fb761acc0bb2249bec375883a093" title="Get (a portion of) the match set for the current query.">get_mset()</a> will have only the "best" (at most) <em>collapse_max</em> entries with each particular value of <em>collapse_key</em> ("best" being highest ranked - i.e. highest weight or highest sorting key).<p>
An example use might be to create a value for each document containing an MD5 hash of the document contents. Then duplicate documents from different sources can be eliminated at search time by collapsing with <em>collapse_max</em> = 1 (it's better to eliminate duplicates at index time, but this may not be always be possible - for example the search may be over more than one <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> database).<p>
Another use is to group matches in a particular category (e.g. you might collapse a mailing list search on the Subject: so that there's only one result per discussion thread). In this case you can use get_collapse_count() to give the user some idea how many other results there are. And if you index the Subject: as a boolean term as well as putting it in a value, you can offer a link to a non-collapsed search restricted to that thread using a boolean filter. 
</div>
</div><p>
<a class="anchor" name="dadaa8401e40ab4cec090bc1541a11b7"></a><!-- doxytag: member="Xapian::Enquire::set_cutoff" ref="dadaa8401e40ab4cec090bc1541a11b7" args="(Xapian::percent percent_cutoff, Xapian::weight weight_cutoff=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_cutoff           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#22ea0a80c58a2047dd929621b75ed9a2">Xapian::percent</a>&nbsp;</td>
          <td class="paramname"> <em>percent_cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#cac12803afc9e24ee5141c119acb8884">Xapian::weight</a>&nbsp;</td>
          <td class="paramname"> <em>weight_cutoff</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the percentage and/or weight cutoffs. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>percent_cutoff</em>&nbsp;</td><td>Minimum percentage score for returned documents. If a document has a lower percentage score than this, it will not appear in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. If your intention is to return only matches which contain all the terms in the query, then it's more efficient to use <a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bb99aad2dfc85eccc56163bc65eb0fdda" title="Return iff both subqueries are satisfied.">Xapian::Query::OP_AND</a> instead of <a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b" title="Return if either subquery is satisfied.">Xapian::Query::OP_OR</a> in the query than to use set_cutoff(100). (default 0 =&gt; no percentage cut-off). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weight_cutoff</em>&nbsp;</td><td>Minimum weight for a document to be returned. If a document has a lower score that this, it will not appear in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. It is usually only possible to choose an appropriate weight for cutoff based on the results of a previous run of the same query; this is thus mainly useful for alerting operations. The other potential use is with a user specified weighting scheme. (default 0 =&gt; no weight cut-off). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bbf7ff734ff6adcb301e493f6eed803b"></a><!-- doxytag: member="Xapian::Enquire::set_docid_order" ref="bbf7ff734ff6adcb301e493f6eed803b" args="(docid_order order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_docid_order           </td>
          <td>(</td>
          <td class="paramtype">docid_order&nbsp;</td>
          <td class="paramname"> <em>order</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the direction in which documents are ordered by document id in the returned <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet).">MSet</a>. 
<p>
This order only has an effect on documents which would otherwise have equal rank. For a weighted probabilistic match with no sort value, this means documents with equal weight. For a boolean match, with no sort value, this means all documents. And if a sort value is used, this means documents with equal sort value (and also equal weight if ordering on relevance after the sort).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>order</em>&nbsp;</td><td>This can be:<ul>
<li>Xapian::Enquire::ASCENDING docids sort in ascending order (default)</li><li>Xapian::Enquire::DESCENDING docids sort in descending order</li><li>Xapian::Enquire::DONT_CARE docids sort in whatever order is most efficient for the backend</li></ul>
</td></tr>
  </table>
</dl>
Note: If you add documents in strict date order, then a boolean search - i.e. set_weighting_scheme(Xapian::BoolWeight()) - with set_docid_order(Xapian::Enquire::DESCENDING) is an efficient way to perform "sort by date, newest first", and with set_docid_order(Xapian::Enquire::ASCENDING) a very efficient way to perform "sort by date, oldest first". 
</div>
</div><p>
<a class="anchor" name="1148d960120662e5543e2a2b12620318"></a><!-- doxytag: member="Xapian::Enquire::set_query" ref="1148d960120662e5543e2a2b12620318" args="(const Xapian::Query &amp;query, Xapian::termcount qlen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_query           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>qlen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the query to run. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>query</em>&nbsp;</td><td>the new query to run. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qlen</em>&nbsp;</td><td>the query length to use in weight calculations - by default the sum of the wqf of all terms is used. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0bcb7086d8633fc035c6e5d094e45d39"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_key" ref="0bcb7086d8633fc035c6e5d094e45d39" args="(Xapian::KeyMaker *sorter, bool reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *&nbsp;</td>
          <td class="paramname"> <em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by key generated from values only. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sorter</em>&nbsp;</td><td>The functor to use for generating keys.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="562beac4843f310dbdc61fdd33209be4"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_key_then_relevance" ref="562beac4843f310dbdc61fdd33209be4" args="(Xapian::KeyMaker *sorter, bool reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_key_then_relevance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *&nbsp;</td>
          <td class="paramname"> <em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by keys generated from values, then by relevance for documents with identical keys. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sorter</em>&nbsp;</td><td>The functor to use for generating keys.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="80a33a28791c05167204706c1a9d986b"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_relevance" ref="80a33a28791c05167204706c1a9d986b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by relevance only. 
<p>
This is the default. 
</div>
</div><p>
<a class="anchor" name="c64b07e06a24519baf1c495d0edcd0c3"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_relevance_then_key" ref="c64b07e06a24519baf1c495d0edcd0c3" args="(Xapian::KeyMaker *sorter, bool reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance_then_key           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *&nbsp;</td>
          <td class="paramname"> <em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by relevance, then by keys generated from values. 
<p>
Note that with the default BM25 weighting scheme parameters, non-identical documents will rarely have the same weight, so this setting will give very similar results to <a class="el" href="classXapian_1_1Enquire.html#80a33a28791c05167204706c1a9d986b" title="Set the sorting to be by relevance only.">set_sort_by_relevance()</a>. It becomes more useful with particular BM25 parameter settings (e.g. BM25Weight(1,0,1,0,0)) or custom weighting schemes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sorter</em>&nbsp;</td><td>The functor to use for generating keys.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order of the generated keys. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5a495760d5edc479385b14b463affbff"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_relevance_then_value" ref="5a495760d5edc479385b14b463affbff" args="(Xapian::valueno sort_key, bool reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance_then_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by relevance then value. 
<p>
Note that sorting by values uses a string comparison, so to use this to sort by a numeric value you'll need to store the numeric values in a manner which sorts appropriately. For example, you could use <a class="el" href="namespaceXapian.html#29a741b4cda98e10ed5f2fc784039065" title="Convert a floating point number to a string, preserving sort order.">Xapian::sortable_serialise()</a> (which works for floating point numbers as well as integers), or store numbers padded with leading zeros or spaces, or with the number of digits prepended.<p>
Note that with the default BM25 weighting scheme parameters, non-identical documents will rarely have the same weight, so this setting will give very similar results to <a class="el" href="classXapian_1_1Enquire.html#80a33a28791c05167204706c1a9d986b" title="Set the sorting to be by relevance only.">set_sort_by_relevance()</a>. It becomes more useful with particular BM25 parameter settings (e.g. BM25Weight(1,0,1,0,0)) or custom weighting schemes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sort_key</em>&nbsp;</td><td>value number to sort on.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order of sort_key. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b10384fabd51eebd8174f916563e3f7a"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_value" ref="b10384fabd51eebd8174f916563e3f7a" args="(Xapian::valueno sort_key, bool reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_value           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by value only. 
<p>
Note that sorting by values uses a string comparison, so to use this to sort by a numeric value you'll need to store the numeric values in a manner which sorts appropriately. For example, you could use <a class="el" href="namespaceXapian.html#29a741b4cda98e10ed5f2fc784039065" title="Convert a floating point number to a string, preserving sort order.">Xapian::sortable_serialise()</a> (which works for floating point numbers as well as integers), or store numbers padded with leading zeros or spaces, or with the number of digits prepended.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sort_key</em>&nbsp;</td><td>value number to sort on.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a921b3c9386fbe2ddfd7dbbf130f9391"></a><!-- doxytag: member="Xapian::Enquire::set_sort_by_value_then_relevance" ref="a921b3c9386fbe2ddfd7dbbf130f9391" args="(Xapian::valueno sort_key, bool reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_value_then_relevance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reverse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the sorting to be by value, then by relevance for documents with the same value. 
<p>
Note that sorting by values uses a string comparison, so to use this to sort by a numeric value you'll need to store the numeric values in a manner which sorts appropriately. For example, you could use <a class="el" href="namespaceXapian.html#29a741b4cda98e10ed5f2fc784039065" title="Convert a floating point number to a string, preserving sort order.">Xapian::sortable_serialise()</a> (which works for floating point numbers as well as integers), or store numbers padded with leading zeros or spaces, or with the number of digits prepended.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sort_key</em>&nbsp;</td><td>value number to sort on.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reverse</em>&nbsp;</td><td>If true, reverses the sort order. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d5c72e6f34c5c2da5f0b8c79736704ab"></a><!-- doxytag: member="Xapian::Enquire::set_weighting_scheme" ref="d5c72e6f34c5c2da5f0b8c79736704ab" args="(const Weight &amp;weight_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_weighting_scheme           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Weight.html">Weight</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>weight_</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the weighting scheme to use for queries. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weight_</em>&nbsp;</td><td>the new weighting scheme. If no weighting scheme is specified, the default is BM25 with the default parameters. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="enquire_8h.html">enquire.h</a></ul>
</div>
<hr>
<address><small>
Documentation for Xapian (version 1.2.13).<br>
Generated on 9 Jan 2013 by
<a href="http://www.doxygen.org/">Doxygen 1.5.9</a>.
</small></address>
</body>
</html>
