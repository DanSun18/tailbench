<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: xapian-core: Xapian::Query Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceXapian.html">Xapian</a>::<a class="el" href="classXapian_1_1Query.html">Query</a>
  </div>
</div>
<div class="contents">
<h1>Xapian::Query Class Reference</h1><!-- doxytag: class="Xapian::Query" -->Class representing a query.  
<a href="#_details">More...</a>
<p>

<p>
<a href="classXapian_1_1Query-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">op</a> { <br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bb99aad2dfc85eccc56163bc65eb0fdda">OP_AND</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b">OP_OR</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bda56688a72af48cc1cee70a5b36f2a94">OP_AND_NOT</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b3f186e28a8cc2a5c4cb99745dda5cedf">OP_XOR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b5990dfefc0a0a63861630b743f507356">OP_AND_MAYBE</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bc657f344bf26128ab7bf8fe25410b102">OP_FILTER</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b7a78c8353d5d06d3a38c1899ae762b21">OP_NEAR</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bce19bf1e7b2d8aa393aabdd061a0866e">OP_PHRASE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b25ad30ce2b6661570ffacd8f910b6d34">OP_VALUE_RANGE</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b0fecaeeb3caa94b1a578fd7953cc60ee">OP_SCALE_WEIGHT</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b9a010fd66a56d9242d6dfae2bae0850b">OP_ELITE_SET</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bf914b109cfe787be77e7c92c99626f01">OP_VALUE_GE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bd6cede66b463ceb5f689979e1b6a8a55">OP_VALUE_LE</a>, 
<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bd8456bafb560c984aff9b4d90a00d36e">OP_SYNONYM</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum of possible query operations.  <a href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a95690337034e432c8e5e82bdfff80ea">Query</a> (const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;copyme)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a95690337034e432c8e5e82bdfff80ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#edfe00f53f010c76c290a0a14873c7a9">operator=</a> (const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;copyme)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment.  <a href="#edfe00f53f010c76c290a0a14873c7a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#836b588120b705758f2e25b67c781b4c">Query</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor: makes an empty query which matches no documents.  <a href="#836b588120b705758f2e25b67c781b4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#420644d38cde25cef056d18ce7fe1c31">~Query</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#420644d38cde25cef056d18ce7fe1c31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#f396e213df0d8bcffa473a75ebf228d6">Query</a> (const std::string &amp;tname_, <a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> wqf_=1, <a class="el" href="namespaceXapian.html#e5a16f073d0c8ed54085a9de07248d45">Xapian::termpos</a> pos_=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A query consisting of a single term.  <a href="#f396e213df0d8bcffa473a75ebf228d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#cd51f1304501311c8dde31dc54c36048">Query</a> (<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> op_, const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;left, const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;right)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A query consisting of two subqueries, opp-ed together.  <a href="#cd51f1304501311c8dde31dc54c36048"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#1e5e506b8659c9c1be88837dcf643163">Query</a> (<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> op_, const std::string &amp;left, const std::string &amp;right)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A query consisting of two termnames opp-ed together.  <a href="#1e5e506b8659c9c1be88837dcf643163"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#a2edfc5e6ae285afb9fde26d096c5ed8">Query</a> (<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> op_, Iterator qbegin, Iterator qend, <a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> parameter=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine a number of <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a>-s with the specified operator.  <a href="#a2edfc5e6ae285afb9fde26d096c5ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4004922547fec06087dc8a63ac484f9b"></a><!-- doxytag: member="Xapian::Query::Query" ref="4004922547fec06087dc8a63ac484f9b" args="(Query::op op_, Xapian::Query q, double parameter)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#4004922547fec06087dc8a63ac484f9b">Query</a> (<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> op_, <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> q, double parameter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply the specified operator to a single <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object, with a double parameter. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#27acaeb8ab8a0c111805a0139e3dc35b">Query</a> (<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> op_, <a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> slot, const std::string &amp;begin, const std::string &amp;end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a value range query on a document value.  <a href="#27acaeb8ab8a0c111805a0139e3dc35b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#15e26a7bf7de2699377cad9e9448a482">Query</a> (<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> op_, <a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> slot, const std::string &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a value comparison query on a document value.  <a href="#15e26a7bf7de2699377cad9e9448a482"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#670caefccf000a24078c05c39959e5e1">Query</a> (<a class="el" href="classXapian_1_1PostingSource.html">Xapian::PostingSource</a> *external_source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an external source query.  <a href="#670caefccf000a24078c05c39959e5e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#de144c7f420490da9b48373e80e2c604">get_length</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the length of the query, used by some ranking formulae.  <a href="#de144c7f420490da9b48373e80e2c604"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#e290b52f21e5652067b202b78f8c03db">get_terms_begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classXapian_1_1TermIterator.html" title="An iterator pointing to items in a list of terms.">Xapian::TermIterator</a> returning all the terms in the query, in order of termpos.  <a href="#e290b52f21e5652067b202b78f8c03db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c31fa68e27c1dcd54a4bd7b637fec062"></a><!-- doxytag: member="Xapian::Query::get_terms_end" ref="c31fa68e27c1dcd54a4bd7b637fec062" args="() const " -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#c31fa68e27c1dcd54a4bd7b637fec062">get_terms_end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a <a class="el" href="classXapian_1_1TermIterator.html" title="An iterator pointing to items in a list of terms.">Xapian::TermIterator</a> to the end of the list of terms in the query. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#7c8bd61280be052e5fabc552d2b20f8c">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test if the query is empty (i.e.  <a href="#7c8bd61280be052e5fabc552d2b20f8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#700503062c18424e606d7f906cc7cd12">serialise</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialise query into a string.  <a href="#700503062c18424e606d7f906cc7cd12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c9d1e428cdddcf5250f10b814eb4bb30"></a><!-- doxytag: member="Xapian::Query::get_description" ref="c9d1e428cdddcf5250f10b814eb4bb30" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#c9d1e428cdddcf5250f10b814eb4bb30">get_description</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing this object. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classXapian_1_1Query.html">Query</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#6475f2f7396c2fb64fb38929a359b6d4">unserialise</a> (const std::string &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unserialise a query from a string produced by <a class="el" href="classXapian_1_1Query.html#700503062c18424e606d7f906cc7cd12" title="Serialise query into a string.">serialise()</a>.  <a href="#6475f2f7396c2fb64fb38929a359b6d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classXapian_1_1Query.html">Query</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#d582d5cd0bfd2719097708ed374b41f9">unserialise</a> (const std::string &amp;s, const <a class="el" href="classXapian_1_1Registry.html">Registry</a> &amp;registry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unserialise a query from a string produced by <a class="el" href="classXapian_1_1Query.html#700503062c18424e606d7f906cc7cd12" title="Serialise query into a string.">serialise()</a>.  <a href="#d582d5cd0bfd2719097708ed374b41f9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#9e30b80314359e5ddd7ca4ffa84b6edd">MatchAll</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A query which matches all documents in the database.  <a href="#9e30b80314359e5ddd7ca4ffa84b6edd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Query.html#5d2584f441d85a126004699479df0350">MatchNothing</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A query which matches no documents.  <a href="#5d2584f441d85a126004699479df0350"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class representing a query. 
<p>
Queries are represented as a tree of objects. <hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100b"></a><!-- doxytag: member="Xapian::Query::op" ref="7e7b6b8ad0c915c2364578dfaaf6100b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Xapian::Query::op</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum of possible query operations. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100bb99aad2dfc85eccc56163bc65eb0fdda"></a><!-- doxytag: member="OP_AND" ref="7e7b6b8ad0c915c2364578dfaaf6100bb99aad2dfc85eccc56163bc65eb0fdda" args="" -->OP_AND</em>&nbsp;</td><td>
Return iff both subqueries are satisfied. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b"></a><!-- doxytag: member="OP_OR" ref="7e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b" args="" -->OP_OR</em>&nbsp;</td><td>
Return if either subquery is satisfied. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100bda56688a72af48cc1cee70a5b36f2a94"></a><!-- doxytag: member="OP_AND_NOT" ref="7e7b6b8ad0c915c2364578dfaaf6100bda56688a72af48cc1cee70a5b36f2a94" args="" -->OP_AND_NOT</em>&nbsp;</td><td>
Return if left but not right satisfied. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100b3f186e28a8cc2a5c4cb99745dda5cedf"></a><!-- doxytag: member="OP_XOR" ref="7e7b6b8ad0c915c2364578dfaaf6100b3f186e28a8cc2a5c4cb99745dda5cedf" args="" -->OP_XOR</em>&nbsp;</td><td>
Return if one query satisfied, but not both. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100b5990dfefc0a0a63861630b743f507356"></a><!-- doxytag: member="OP_AND_MAYBE" ref="7e7b6b8ad0c915c2364578dfaaf6100b5990dfefc0a0a63861630b743f507356" args="" -->OP_AND_MAYBE</em>&nbsp;</td><td>
Return iff left satisfied, but use weights from both. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100bc657f344bf26128ab7bf8fe25410b102"></a><!-- doxytag: member="OP_FILTER" ref="7e7b6b8ad0c915c2364578dfaaf6100bc657f344bf26128ab7bf8fe25410b102" args="" -->OP_FILTER</em>&nbsp;</td><td>
As AND, but use only weights from left subquery. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100b7a78c8353d5d06d3a38c1899ae762b21"></a><!-- doxytag: member="OP_NEAR" ref="7e7b6b8ad0c915c2364578dfaaf6100b7a78c8353d5d06d3a38c1899ae762b21" args="" -->OP_NEAR</em>&nbsp;</td><td>
Find occurrences of a list of terms with all the terms occurring within a specified window of positions. 
<p>
Each occurrence of a term must be at a different position, but the order they appear in is irrelevant.<p>
The window parameter should be specified for this operation, but will default to the number of terms in the list. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100bce19bf1e7b2d8aa393aabdd061a0866e"></a><!-- doxytag: member="OP_PHRASE" ref="7e7b6b8ad0c915c2364578dfaaf6100bce19bf1e7b2d8aa393aabdd061a0866e" args="" -->OP_PHRASE</em>&nbsp;</td><td>
Find occurrences of a list of terms with all the terms occurring within a specified window of positions, and all the terms appearing in the order specified. 
<p>
Each occurrence of a term must be at a different position.<p>
The window parameter should be specified for this operation, but will default to the number of terms in the list. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100b25ad30ce2b6661570ffacd8f910b6d34"></a><!-- doxytag: member="OP_VALUE_RANGE" ref="7e7b6b8ad0c915c2364578dfaaf6100b25ad30ce2b6661570ffacd8f910b6d34" args="" -->OP_VALUE_RANGE</em>&nbsp;</td><td>
Filter by a range test on a document value. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100b0fecaeeb3caa94b1a578fd7953cc60ee"></a><!-- doxytag: member="OP_SCALE_WEIGHT" ref="7e7b6b8ad0c915c2364578dfaaf6100b0fecaeeb3caa94b1a578fd7953cc60ee" args="" -->OP_SCALE_WEIGHT</em>&nbsp;</td><td>
Scale the weight of a subquery by the specified factor. 
<p>
A factor of 0 means this subquery will contribute no weight to the query - it will act as a purely boolean subquery.<p>
If the factor is negative, <a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a> will be thrown. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100b9a010fd66a56d9242d6dfae2bae0850b"></a><!-- doxytag: member="OP_ELITE_SET" ref="7e7b6b8ad0c915c2364578dfaaf6100b9a010fd66a56d9242d6dfae2bae0850b" args="" -->OP_ELITE_SET</em>&nbsp;</td><td>
Pick the best N subqueries and combine with OP_OR. 
<p>
If you want to implement a feature which finds documents similar to a piece of text, an obvious approach is to build an "OR" query from all the terms in the text, and run this query against a database containing the documents. However such a query can contain a lots of terms and be quite slow to perform, yet many of these terms don't contribute usefully to the results.<p>
The OP_ELITE_SET operator can be used instead of OP_OR in this situation. OP_ELITE_SET selects the most important ''N'' terms and then acts as an OP_OR query with just these, ignoring any other terms. This will usually return results just as good as the full OP_OR query, but much faster.<p>
In general, the OP_ELITE_SET operator can be used when you have a large OR query, but it doesn't matter if the search completely ignores some of the less important terms in the query.<p>
The subqueries don't have to be terms, but if they aren't then OP_ELITE_SET will look at the estimated frequencies of the subqueries and so could pick a subset which don't actually match any documents even if the full OR would match some.<p>
You can specify a parameter to the query constructor which control the number of terms which OP_ELITE_SET will pick. If not specified, this defaults to 10 (or <code>ceil(sqrt(number_of_subqueries))</code> if there are more than 100 subqueries, but this rather arbitrary special case will be dropped in 1.3.0). For example, this will pick the best 7 terms:<p>
<pre>
  <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> query(<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b9a010fd66a56d9242d6dfae2bae0850b" title="Pick the best N subqueries and combine with OP_OR.">Xapian::Query::OP_ELITE_SET</a>, subqs.begin(), subqs.end(), 7);
  </pre><p>
If the number of subqueries is less than this threshold, OP_ELITE_SET behaves identically to OP_OR. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100bf914b109cfe787be77e7c92c99626f01"></a><!-- doxytag: member="OP_VALUE_GE" ref="7e7b6b8ad0c915c2364578dfaaf6100bf914b109cfe787be77e7c92c99626f01" args="" -->OP_VALUE_GE</em>&nbsp;</td><td>
Filter by a greater-than-or-equal test on a document value. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100bd6cede66b463ceb5f689979e1b6a8a55"></a><!-- doxytag: member="OP_VALUE_LE" ref="7e7b6b8ad0c915c2364578dfaaf6100bd6cede66b463ceb5f689979e1b6a8a55" args="" -->OP_VALUE_LE</em>&nbsp;</td><td>
Filter by a less-than-or-equal test on a document value. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="7e7b6b8ad0c915c2364578dfaaf6100bd8456bafb560c984aff9b4d90a00d36e"></a><!-- doxytag: member="OP_SYNONYM" ref="7e7b6b8ad0c915c2364578dfaaf6100bd8456bafb560c984aff9b4d90a00d36e" args="" -->OP_SYNONYM</em>&nbsp;</td><td>
Treat a set of queries as synonyms. 
<p>
This returns all results which match at least one of the queries, but weighting as if all the sub-queries are instances of the same term: so multiple matching terms for a document increase the wdf value used, and the term frequency is based on the number of documents which would match an OR of all the subqueries.<p>
The term frequency used will usually be an approximation, because calculating the precise combined term frequency would be overly expensive.<p>
Identical to OP_OR, except for the weightings returned. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a95690337034e432c8e5e82bdfff80ea"></a><!-- doxytag: member="Xapian::Query::Query" ref="a95690337034e432c8e5e82bdfff80ea" args="(const Query &amp;copyme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyme</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="836b588120b705758f2e25b67c781b4c"></a><!-- doxytag: member="Xapian::Query::Query" ref="836b588120b705758f2e25b67c781b4c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor: makes an empty query which matches no documents. 
<p>
Also useful for defining a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> object to be assigned to later.<p>
An exception will be thrown if an attempt is made to use an undefined query when building up a composite query. 
</div>
</div><p>
<a class="anchor" name="420644d38cde25cef056d18ce7fe1c31"></a><!-- doxytag: member="Xapian::Query::~Query" ref="420644d38cde25cef056d18ce7fe1c31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::~Query           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<a class="anchor" name="f396e213df0d8bcffa473a75ebf228d6"></a><!-- doxytag: member="Xapian::Query::Query" ref="f396e213df0d8bcffa473a75ebf228d6" args="(const std::string &amp;tname_, Xapian::termcount wqf_=1, Xapian::termpos pos_=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>tname_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>wqf_</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#e5a16f073d0c8ed54085a9de07248d45">Xapian::termpos</a>&nbsp;</td>
          <td class="paramname"> <em>pos_</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A query consisting of a single term. 
<p>

</div>
</div><p>
<a class="anchor" name="cd51f1304501311c8dde31dc54c36048"></a><!-- doxytag: member="Xapian::Query::Query" ref="cd51f1304501311c8dde31dc54c36048" args="(Query::op op_, const Query &amp;left, const Query &amp;right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&nbsp;</td>
          <td class="paramname"> <em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A query consisting of two subqueries, opp-ed together. 
<p>

</div>
</div><p>
<a class="anchor" name="1e5e506b8659c9c1be88837dcf643163"></a><!-- doxytag: member="Xapian::Query::Query" ref="1e5e506b8659c9c1be88837dcf643163" args="(Query::op op_, const std::string &amp;left, const std::string &amp;right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&nbsp;</td>
          <td class="paramname"> <em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A query consisting of two termnames opp-ed together. 
<p>

</div>
</div><p>
<a class="anchor" name="a2edfc5e6ae285afb9fde26d096c5ed8"></a><!-- doxytag: member="Xapian::Query::Query" ref="a2edfc5e6ae285afb9fde26d096c5ed8" args="(Query::op op_, Iterator qbegin, Iterator qend, Xapian::termcount parameter=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&nbsp;</td>
          <td class="paramname"> <em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>qbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>qend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>parameter</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Combine a number of <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a>-s with the specified operator. 
<p>
The <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> objects are specified with begin and end iterators.<p>
AND, OR, XOR, ELITE_SET, SYNONYM, NEAR and PHRASE can take any number of subqueries. Other operators take exactly two subqueries.<p>
The iterators may be to <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> objects, pointers to <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> objects, or termnames (std::string-s).<p>
For NEAR and PHRASE, a window size can be specified in parameter.<p>
For ELITE_SET, the elite set size can be specified in parameter. 
</div>
</div><p>
<a class="anchor" name="27acaeb8ab8a0c111805a0139e3dc35b"></a><!-- doxytag: member="Xapian::Query::Query" ref="27acaeb8ab8a0c111805a0139e3dc35b" args="(Query::op op_, Xapian::valueno slot, const std::string &amp;begin, const std::string &amp;end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&nbsp;</td>
          <td class="paramname"> <em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a value range query on a document value. 
<p>
A value range query matches those documents which have a value stored in the slot given by <em>slot</em> which is in the range specified by <em>begin</em> and <em>end</em> (in lexicographical order), including the endpoints.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op_</em>&nbsp;</td><td>The operator to use for the query. Currently, must be OP_VALUE_RANGE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>The slot number to get the value from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>The start of the range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end of the range. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="15e26a7bf7de2699377cad9e9448a482"></a><!-- doxytag: member="Xapian::Query::Query" ref="15e26a7bf7de2699377cad9e9448a482" args="(Query::op op_, Xapian::valueno slot, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&nbsp;</td>
          <td class="paramname"> <em>op_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&nbsp;</td>
          <td class="paramname"> <em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a value comparison query on a document value. 
<p>
This query matches those documents which have a value stored in the slot given by <em>slot</em> which compares, as specified by the operator, to <em>value</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op_</em>&nbsp;</td><td>The operator to use for the query. Currently, must be OP_VALUE_GE or OP_VALUE_LE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slot</em>&nbsp;</td><td>The slot number to get the value from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to compare. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="670caefccf000a24078c05c39959e5e1"></a><!-- doxytag: member="Xapian::Query::Query" ref="670caefccf000a24078c05c39959e5e1" args="(Xapian::PostingSource *external_source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Query::Query           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1PostingSource.html">Xapian::PostingSource</a> *&nbsp;</td>
          <td class="paramname"> <em>external_source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an external source query. 
<p>
An attempt to clone the posting source will be made immediately, so if the posting source supports clone(), the source supplied may be safely deallocated after this call. If the source does not support clone(), the caller must ensure that the posting source remains valid until the <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Query</a> is deallocated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>external_source</em>&nbsp;</td><td>The source to use in the query. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="7c8bd61280be052e5fabc552d2b20f8c"></a><!-- doxytag: member="Xapian::Query::empty" ref="7c8bd61280be052e5fabc552d2b20f8c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Xapian::Query::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test if the query is empty (i.e. 
<p>
was constructed using the default ctor or with an empty iterator ctor). 
</div>
</div><p>
<a class="anchor" name="de144c7f420490da9b48373e80e2c604"></a><!-- doxytag: member="Xapian::Query::get_length" ref="de144c7f420490da9b48373e80e2c604" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> Xapian::Query::get_length           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the length of the query, used by some ranking formulae. 
<p>
This value is calculated automatically - if you want to override it you can pass a different value to <a class="el" href="classXapian_1_1Enquire.html#1148d960120662e5543e2a2b12620318" title="Set the query to run.">Enquire::set_query()</a>. 
</div>
</div><p>
<a class="anchor" name="e290b52f21e5652067b202b78f8c03db"></a><!-- doxytag: member="Xapian::Query::get_terms_begin" ref="e290b52f21e5652067b202b78f8c03db" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Query::get_terms_begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a <a class="el" href="classXapian_1_1TermIterator.html" title="An iterator pointing to items in a list of terms.">Xapian::TermIterator</a> returning all the terms in the query, in order of termpos. 
<p>
If multiple terms have the same term position, their order is unspecified. Duplicates (same term and termpos) will be removed. 
</div>
</div><p>
<a class="anchor" name="edfe00f53f010c76c290a0a14873c7a9"></a><!-- doxytag: member="Xapian::Query::operator=" ref="edfe00f53f010c76c290a0a14873c7a9" args="(const Query &amp;copyme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html">Query</a>&amp; Xapian::Query::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copyme</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment. 
<p>

</div>
</div><p>
<a class="anchor" name="700503062c18424e606d7f906cc7cd12"></a><!-- doxytag: member="Xapian::Query::serialise" ref="700503062c18424e606d7f906cc7cd12" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xapian::Query::serialise           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Serialise query into a string. 
<p>
The query representation may change between <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> releases: even between minor versions. However, it is guaranteed not to change unless the remote database protocol has also changed between releases. 
</div>
</div><p>
<a class="anchor" name="d582d5cd0bfd2719097708ed374b41f9"></a><!-- doxytag: member="Xapian::Query::unserialise" ref="d582d5cd0bfd2719097708ed374b41f9" args="(const std::string &amp;s, const Registry &amp;registry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::Query::unserialise           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Registry.html">Registry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>registry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unserialise a query from a string produced by <a class="el" href="classXapian_1_1Query.html#700503062c18424e606d7f906cc7cd12" title="Serialise query into a string.">serialise()</a>. 
<p>
The supplied registry will be used to attempt to unserialise any external <a class="el" href="classXapian_1_1PostingSource.html" title="Base class which provides an &quot;external&quot; source of postings.">PostingSource</a> leaf nodes. This method will fail if the query contains any external <a class="el" href="classXapian_1_1PostingSource.html" title="Base class which provides an &quot;external&quot; source of postings.">PostingSource</a> leaf nodes which are not registered in the registry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string representing the serialised query. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>registry</em>&nbsp;</td><td><a class="el" href="classXapian_1_1Registry.html" title="Registry for user subclasses.">Xapian::Registry</a> to use. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6475f2f7396c2fb64fb38929a359b6d4"></a><!-- doxytag: member="Xapian::Query::unserialise" ref="6475f2f7396c2fb64fb38929a359b6d4" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::Query::unserialise           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unserialise a query from a string produced by <a class="el" href="classXapian_1_1Query.html#700503062c18424e606d7f906cc7cd12" title="Serialise query into a string.">serialise()</a>. 
<p>
This method will fail if the query contains any external <a class="el" href="classXapian_1_1PostingSource.html" title="Base class which provides an &quot;external&quot; source of postings.">PostingSource</a> leaf nodes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string representing the serialised query. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="9e30b80314359e5ddd7ca4ffa84b6edd"></a><!-- doxytag: member="Xapian::Query::MatchAll" ref="9e30b80314359e5ddd7ca4ffa84b6edd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> <a class="el" href="classXapian_1_1Query.html#9e30b80314359e5ddd7ca4ffa84b6edd">Xapian::Query::MatchAll</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A query which matches all documents in the database. 
<p>

</div>
</div><p>
<a class="anchor" name="5d2584f441d85a126004699479df0350"></a><!-- doxytag: member="Xapian::Query::MatchNothing" ref="5d2584f441d85a126004699479df0350" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> <a class="el" href="classXapian_1_1Query.html#5d2584f441d85a126004699479df0350">Xapian::Query::MatchNothing</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A query which matches no documents. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="query_8h.html">query.h</a></ul>
</div>
<hr>
<address><small>
Documentation for Xapian (version 1.2.13).<br>
Generated on 9 Jan 2013 by
<a href="http://www.doxygen.org/">Doxygen 1.5.9</a>.
</small></address>
</body>
</html>
