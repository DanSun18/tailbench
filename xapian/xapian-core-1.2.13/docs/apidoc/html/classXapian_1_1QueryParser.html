<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: xapian-core: Xapian::QueryParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceXapian.html">Xapian</a>::<a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a>
  </div>
</div>
<div class="contents">
<h1>Xapian::QueryParser Class Reference</h1><!-- doxytag: class="Xapian::QueryParser" -->Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object from a user query string.  
<a href="#_details">More...</a>
<p>

<p>
<a href="classXapian_1_1QueryParser-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e">feature_flag</a> { <br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407effc56acef4c5b0da425d4ea74b7affde">FLAG_BOOLEAN</a> =  1, 
<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407ed7e3ef99f48e26f40836a2e98ac86e6b">FLAG_PHRASE</a> =  2, 
<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e0c7c618a79df1201ef342951450447cd">FLAG_LOVEHATE</a> =  4, 
<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e9046353051e08dd0149b4fced176ed3d">FLAG_BOOLEAN_ANY_CASE</a> =  8, 
<br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a> =  16, 
<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407ecafc7c8cf7c90adac0fc07d02125aed0">FLAG_PURE_NOT</a> =  32, 
<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407ee0b632c2f797fc7ae53c444f104072c7">FLAG_PARTIAL</a> =  64, 
<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407eacef09c368bdafe64debabe112f1024c">FLAG_SPELLING_CORRECTION</a> =  128, 
<br>
&nbsp;&nbsp;<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407ea139c20751d70cc6d19d7541160d7d3f">FLAG_SYNONYM</a> =  256, 
<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e15716c0dcfe839e7d9a8e8337bbed16b">FLAG_AUTO_SYNONYMS</a> =  512, 
<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e175afae857d6aa6a4aecccfe8793be1b">FLAG_AUTO_MULTIWORD_SYNONYMS</a> =  1024 | FLAG_AUTO_SYNONYMS, 
<a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a> =  FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enum of feature flags.  <a href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#e2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stemming strategies, for use with <a class="el" href="classXapian_1_1QueryParser.html#c7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy.">set_stemming_strategy()</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="00d9afcf20b20cd9c8b3d22dd1bc82b7"></a><!-- doxytag: member="Xapian::QueryParser::QueryParser" ref="00d9afcf20b20cd9c8b3d22dd1bc82b7" args="(const QueryParser &amp;o)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#00d9afcf20b20cd9c8b3d22dd1bc82b7">QueryParser</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="18adb637032c2149a0457f2f79f332a5"></a><!-- doxytag: member="Xapian::QueryParser::operator=" ref="18adb637032c2149a0457f2f79f332a5" args="(const QueryParser &amp;o)" -->
<a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#18adb637032c2149a0457f2f79f332a5">operator=</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="724f1e26b785516c4c8cde78455f9cd5"></a><!-- doxytag: member="Xapian::QueryParser::QueryParser" ref="724f1e26b785516c4c8cde78455f9cd5" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#724f1e26b785516c4c8cde78455f9cd5">QueryParser</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="69d48b819b0c6d6a29f86a756f91d047"></a><!-- doxytag: member="Xapian::QueryParser::~QueryParser" ref="69d48b819b0c6d6a29f86a756f91d047" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#69d48b819b0c6d6a29f86a756f91d047">~QueryParser</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#2312c9865a58cc1149fe7cda9f0c2585">set_stemmer</a> (const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;stemmer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stemmer.  <a href="#2312c9865a58cc1149fe7cda9f0c2585"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#c7dc3b55b6083bd3ff98fc8b2726c8fd">set_stemming_strategy</a> (<a class="el" href="classXapian_1_1QueryParser.html#e2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> strategy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stemming strategy.  <a href="#c7dc3b55b6083bd3ff98fc8b2726c8fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#b1046610676f72ba564108f0df5d77ab">set_stopper</a> (const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *stop=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the stopper.  <a href="#b1046610676f72ba564108f0df5d77ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#2efe48be88c4872afec4bc963f417ea5">set_default_op</a> (<a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> default_op)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the default operator.  <a href="#2efe48be88c4872afec4bc963f417ea5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#4a6323a8aea7734e447de1ba7eab31c1">get_default_op</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current default operator.  <a href="#4a6323a8aea7734e447de1ba7eab31c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#576d221ba746506e51d9ea596ecb2cf6">set_database</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the database being searched.  <a href="#576d221ba746506e51d9ea596ecb2cf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#7651d48cdc661c0605c475925170cc71">set_max_wildcard_expansion</a> (<a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> limit)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify the maximum expansion of a wildcard term.  <a href="#7651d48cdc661c0605c475925170cc71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1Query.html">Query</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#73d32cc7f862ab2e3fdd7da61f352fb2">parse_query</a> (const std::string &amp;query_string, unsigned flags=FLAG_DEFAULT, const std::string &amp;default_prefix=std::string())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a query.  <a href="#73d32cc7f862ab2e3fdd7da61f352fb2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#d4829ddcaa0582ff94d1066870a18c97">add_prefix</a> (const std::string &amp;field, const std::string &amp;prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a probabilistic term prefix.  <a href="#d4829ddcaa0582ff94d1066870a18c97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#67d25f9297bb98c2101a03ff3d60cf30">add_boolean_prefix</a> (const std::string &amp;field, const std::string &amp;prefix, bool exclusive)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query.  <a href="#67d25f9297bb98c2101a03ff3d60cf30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="57ff03cd3fe1fa2b6e07fc347bee3590"></a><!-- doxytag: member="Xapian::QueryParser::stoplist_begin" ref="57ff03cd3fe1fa2b6e07fc347bee3590" args="() const " -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#57ff03cd3fe1fa2b6e07fc347bee3590">stoplist_begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over terms omitted from the query as stopwords. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2088e54f557e2d608247c5237a1bc3b"></a><!-- doxytag: member="Xapian::QueryParser::unstem_begin" ref="a2088e54f557e2d608247c5237a1bc3b" args="(const std::string &amp;term) const " -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2088e54f557e2d608247c5237a1bc3b">unstem_begin</a> (const std::string &amp;term) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over unstemmed forms of the given (stemmed) term used in the query. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8f8583a9f044f2eb33859b442a8aea76"></a><!-- doxytag: member="Xapian::QueryParser::add_valuerangeprocessor" ref="8f8583a9f044f2eb33859b442a8aea76" args="(Xapian::ValueRangeProcessor *vrproc)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#8f8583a9f044f2eb33859b442a8aea76">add_valuerangeprocessor</a> (<a class="el" href="structXapian_1_1ValueRangeProcessor.html">Xapian::ValueRangeProcessor</a> *vrproc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a <a class="el" href="structXapian_1_1ValueRangeProcessor.html" title="Base class for value range processors.">ValueRangeProcessor</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#0e59c760a0a4edacb437621ac66be25a">get_corrected_query_string</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the spelling-corrected query string.  <a href="#0e59c760a0a4edacb437621ac66be25a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="89f9d15f38538a07497fdfc8658852b2"></a><!-- doxytag: member="Xapian::QueryParser::get_description" ref="89f9d15f38538a07497fdfc8658852b2" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#89f9d15f38538a07497fdfc8658852b2">get_description</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing this object. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object from a user query string. <hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407e"></a><!-- doxytag: member="Xapian::QueryParser::feature_flag" ref="e96a58a8de9d219ca3214a5a66e0407e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classXapian_1_1QueryParser.html#e96a58a8de9d219ca3214a5a66e0407e">Xapian::QueryParser::feature_flag</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum of feature flags. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407effc56acef4c5b0da425d4ea74b7affde"></a><!-- doxytag: member="FLAG_BOOLEAN" ref="e96a58a8de9d219ca3214a5a66e0407effc56acef4c5b0da425d4ea74b7affde" args="" -->FLAG_BOOLEAN</em>&nbsp;</td><td>
Support AND, OR, etc and bracketed subexpressions. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407ed7e3ef99f48e26f40836a2e98ac86e6b"></a><!-- doxytag: member="FLAG_PHRASE" ref="e96a58a8de9d219ca3214a5a66e0407ed7e3ef99f48e26f40836a2e98ac86e6b" args="" -->FLAG_PHRASE</em>&nbsp;</td><td>
Support quoted phrases. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407e0c7c618a79df1201ef342951450447cd"></a><!-- doxytag: member="FLAG_LOVEHATE" ref="e96a58a8de9d219ca3214a5a66e0407e0c7c618a79df1201ef342951450447cd" args="" -->FLAG_LOVEHATE</em>&nbsp;</td><td>
Support + and -. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407e9046353051e08dd0149b4fced176ed3d"></a><!-- doxytag: member="FLAG_BOOLEAN_ANY_CASE" ref="e96a58a8de9d219ca3214a5a66e0407e9046353051e08dd0149b4fced176ed3d" args="" -->FLAG_BOOLEAN_ANY_CASE</em>&nbsp;</td><td>
Support AND, OR, etc even if they aren't in ALLCAPS. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407e99e75d48aca2ebbf477572d855c82e36"></a><!-- doxytag: member="FLAG_WILDCARD" ref="e96a58a8de9d219ca3214a5a66e0407e99e75d48aca2ebbf477572d855c82e36" args="" -->FLAG_WILDCARD</em>&nbsp;</td><td>
Support right truncation (e.g. 
<p>
Xap*).<p>
Currently you can't use wildcards with boolean filter prefixes, or in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation).<p>
NB: You need to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> object which database to expand wildcards from by calling set_database. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407ecafc7c8cf7c90adac0fc07d02125aed0"></a><!-- doxytag: member="FLAG_PURE_NOT" ref="e96a58a8de9d219ca3214a5a66e0407ecafc7c8cf7c90adac0fc07d02125aed0" args="" -->FLAG_PURE_NOT</em>&nbsp;</td><td>
Allow queries such as 'NOT apples'. 
<p>
These require the use of a list of all documents in the database which is potentially expensive, so this feature isn't enabled by default. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407ee0b632c2f797fc7ae53c444f104072c7"></a><!-- doxytag: member="FLAG_PARTIAL" ref="e96a58a8de9d219ca3214a5a66e0407ee0b632c2f797fc7ae53c444f104072c7" args="" -->FLAG_PARTIAL</em>&nbsp;</td><td>
Enable partial matching. 
<p>
Partial matching causes the parser to treat the query as a "partially entered" search. This will automatically treat the final word as a wildcarded match, unless it is followed by whitespace, to produce more stable results from interactive searches.<p>
Currently FLAG_PARTIAL doesn't do anything if the final word in the query has a boolean filter prefix, or if it is in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation). It also doesn't do anything if if the final word is part of a value range.<p>
NB: You need to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> object which database to expand wildcards from by calling set_database. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407eacef09c368bdafe64debabe112f1024c"></a><!-- doxytag: member="FLAG_SPELLING_CORRECTION" ref="e96a58a8de9d219ca3214a5a66e0407eacef09c368bdafe64debabe112f1024c" args="" -->FLAG_SPELLING_CORRECTION</em>&nbsp;</td><td>
Enable spelling correction. 
<p>
For each word in the query which doesn't exist as a term in the database, <a class="el" href="classXapian_1_1Database.html#86b944dece96d7ada2446ae8952ee3a2" title="Suggest a spelling correction.">Database::get_spelling_suggestion()</a> will be called and if a suggestion is returned, a corrected version of the query string will be built up which can be read using <a class="el" href="classXapian_1_1QueryParser.html#0e59c760a0a4edacb437621ac66be25a" title="Get the spelling-corrected query string.">QueryParser::get_corrected_query_string()</a>. The query returned is based on the uncorrected query string however - if you want a parsed query based on the corrected query string, you must call <a class="el" href="classXapian_1_1QueryParser.html#73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">QueryParser::parse_query()</a> again.<p>
NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407ea139c20751d70cc6d19d7541160d7d3f"></a><!-- doxytag: member="FLAG_SYNONYM" ref="e96a58a8de9d219ca3214a5a66e0407ea139c20751d70cc6d19d7541160d7d3f" args="" -->FLAG_SYNONYM</em>&nbsp;</td><td>
Enable synonym operator '~'. 
<p>
NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407e15716c0dcfe839e7d9a8e8337bbed16b"></a><!-- doxytag: member="FLAG_AUTO_SYNONYMS" ref="e96a58a8de9d219ca3214a5a66e0407e15716c0dcfe839e7d9a8e8337bbed16b" args="" -->FLAG_AUTO_SYNONYMS</em>&nbsp;</td><td>
Enable automatic use of synonyms for single terms. 
<p>
NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407e175afae857d6aa6a4aecccfe8793be1b"></a><!-- doxytag: member="FLAG_AUTO_MULTIWORD_SYNONYMS" ref="e96a58a8de9d219ca3214a5a66e0407e175afae857d6aa6a4aecccfe8793be1b" args="" -->FLAG_AUTO_MULTIWORD_SYNONYMS</em>&nbsp;</td><td>
Enable automatic use of synonyms for single terms and groups of terms. 
<p>
NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e96a58a8de9d219ca3214a5a66e0407e4e4a5c38e629300d01219456add0ea4a"></a><!-- doxytag: member="FLAG_DEFAULT" ref="e96a58a8de9d219ca3214a5a66e0407e4e4a5c38e629300d01219456add0ea4a" args="" -->FLAG_DEFAULT</em>&nbsp;</td><td>
The default flags. 
<p>
Used if you don't explicitly pass any to <em><a class="el" href="classXapian_1_1QueryParser.html#73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">parse_query()</a></em>. The default flags are FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE.<p>
Added in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.0.11. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="67d25f9297bb98c2101a03ff3d60cf30"></a><!-- doxytag: member="Xapian::QueryParser::add_boolean_prefix" ref="67d25f9297bb98c2101a03ff3d60cf30" args="(const std::string &amp;field, const std::string &amp;prefix, bool exclusive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_boolean_prefix           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>exclusive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query. 
<p>
For example:<p>
<div class="fragment"><pre class="fragment">  qp.add_boolean_prefix(<span class="stringliteral">"site"</span>, <span class="stringliteral">"H"</span>);
</pre></div><p>
This allows the user to restrict a search with site:xapian.org which will be converted to Hxapian.org combined with any probabilistic query with <code><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bc657f344bf26128ab7bf8fe25410b102" title="As AND, but use only weights from left subquery.">Xapian::Query::OP_FILTER</a></code>.<p>
If multiple boolean filters are specified in a query for the same prefix, they will be combined with the <code><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b" title="Return if either subquery is satisfied.">Xapian::Query::OP_OR</a></code> operator. Then, if there are boolean filters for different prefixes, they will be combined with the <code><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bb99aad2dfc85eccc56163bc65eb0fdda" title="Return iff both subqueries are satisfied.">Xapian::Query::OP_AND</a></code> operator.<p>
Multiple fields can be mapped to the same prefix (so for example you can make site: and domain: aliases for each other). Instances of fields with different aliases but the same prefix will still be combined with the OR operator.<p>
For example, if "site" and "domain" map to "H", but author maps to "A", a search for "site:foo domain:bar author:Fred" will map to "(Hfoo OR Hbar) AND Afred".<p>
As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b" title="Return if either subquery is satisfied.">Xapian::Query::OP_OR</a></code>.<p>
Calling this method with an empty string for <em>field</em> will cause a <code><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></code>.<p>
If you call <code><a class="el" href="classXapian_1_1QueryParser.html#d4829ddcaa0582ff94d1066870a18c97" title="Add a probabilistic term prefix.">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#67d25f9297bb98c2101a03ff3d60cf30" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way.">Xapian::InvalidOperationError</a></code> exception will be thrown.<p>
In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>field</em>&nbsp;</td><td>The user visible field name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The term prefix to map this to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exclusive</em>&nbsp;</td><td>If true, each document can have at most one term with this prefix, so multiple filters with this prefix should be combined with OP_OR. If false, each document can have multiple terms with this prefix, so multiple filters should be combined with OP_AND, like happens with filters with different prefixes. [default: true] </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d4829ddcaa0582ff94d1066870a18c97"></a><!-- doxytag: member="Xapian::QueryParser::add_prefix" ref="d4829ddcaa0582ff94d1066870a18c97" args="(const std::string &amp;field, const std::string &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_prefix           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a probabilistic term prefix. 
<p>
For example:<p>
<div class="fragment"><pre class="fragment">  qp.add_prefix(<span class="stringliteral">"author"</span>, <span class="stringliteral">"A"</span>);
</pre></div><p>
This allows the user to search for author:Orwell which will be converted to a search for the term "Aorwell".<p>
Multiple fields can be mapped to the same prefix. For example, you can make title: and subject: aliases for each other.<p>
As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100bc50e54f3dd9dc59dab7daa2c50cf631b" title="Return if either subquery is satisfied.">Xapian::Query::OP_OR</a></code>.<p>
If any prefixes are specified for the empty field name (i.e. you call this method with an empty string as the first parameter) these prefixes will be used for terms without a field specifier. If you do this and also specify the <code>default_prefix</code> parameter to <code><a class="el" href="classXapian_1_1QueryParser.html#73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">parse_query()</a></code>, then the <code>default_prefix</code> parameter will override.<p>
If the prefix parameter is empty, then "field:word" will produce the term "word" (and this can be one of several prefixes for a particular field, or for terms without a field specifier).<p>
If you call <code><a class="el" href="classXapian_1_1QueryParser.html#d4829ddcaa0582ff94d1066870a18c97" title="Add a probabilistic term prefix.">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#67d25f9297bb98c2101a03ff3d60cf30" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way.">Xapian::InvalidOperationError</a></code> exception will be thrown.<p>
In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>field</em>&nbsp;</td><td>The user visible field name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The term prefix to map this to </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e59c760a0a4edacb437621ac66be25a"></a><!-- doxytag: member="Xapian::QueryParser::get_corrected_query_string" ref="0e59c760a0a4edacb437621ac66be25a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xapian::QueryParser::get_corrected_query_string           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the spelling-corrected query string. 
<p>
This will only be set if FLAG_SPELLING_CORRECTION is specified when <a class="el" href="classXapian_1_1QueryParser.html#73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">QueryParser::parse_query()</a> was last called.<p>
If there were no corrections, an empty string is returned. 
</div>
</div><p>
<a class="anchor" name="4a6323a8aea7734e447de1ba7eab31c1"></a><!-- doxytag: member="Xapian::QueryParser::get_default_op" ref="4a6323a8aea7734e447de1ba7eab31c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> Xapian::QueryParser::get_default_op           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current default operator. 
<p>

</div>
</div><p>
<a class="anchor" name="73d32cc7f862ab2e3fdd7da61f352fb2"></a><!-- doxytag: member="Xapian::QueryParser::parse_query" ref="73d32cc7f862ab2e3fdd7da61f352fb2" args="(const std::string &amp;query_string, unsigned flags=FLAG_DEFAULT, const std::string &amp;default_prefix=std::string())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::QueryParser::parse_query           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>query_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>FLAG_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>default_prefix</em> = <code>std::string()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a query. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>query_string</em>&nbsp;</td><td>A free-text query as entered by a user </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Zero or more Query::feature_flag specifying what features the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> should support. Combine multiple values with bitwise-or (|) (default FLAG_DEFAULT). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>default_prefix</em>&nbsp;</td><td>The default term prefix to use (default none). For example, you can pass "A" when parsing an "Author" field.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>If</em>&nbsp;</td><td>the query string can't be parsed, then <a class="el" href="classXapian_1_1QueryParserError.html" title="Indicates a query string can&#39;t be parsed.">Xapian::QueryParserError</a> is thrown. You can get an English error message to report to the user by catching it and calling get_msg() on the caught exception. The current possible values (in case you want to translate them) are:</td></tr>
  </table>
</dl>
<ul>
<li>Unknown range operation </li>
<li>parse error </li>
<li>Syntax: &lt;expression&gt; AND &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; AND NOT &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; NOT &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; OR &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; XOR &lt;expression&gt; </li>
</ul>

</div>
</div><p>
<a class="anchor" name="576d221ba746506e51d9ea596ecb2cf6"></a><!-- doxytag: member="Xapian::QueryParser::set_database" ref="576d221ba746506e51d9ea596ecb2cf6" args="(const Database &amp;db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_database           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>db</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify the database being searched. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>db</em>&nbsp;</td><td>The database to use for wildcard expansion (FLAG_WILDCARD and FLAG_PARTIAL), spelling correction (FLAG_SPELLING_CORRECTION), and synonyms (FLAG_SYNONYM, FLAG_AUTO_SYNONYMS, and FLAG_AUTO_MULTIWORD_SYNONYMS). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2efe48be88c4872afec4bc963f417ea5"></a><!-- doxytag: member="Xapian::QueryParser::set_default_op" ref="2efe48be88c4872afec4bc963f417ea5" args="(Query::op default_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_default_op           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&nbsp;</td>
          <td class="paramname"> <em>default_op</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the default operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>default_op</em>&nbsp;</td><td>The operator to use to combine non-filter query items when no explicit operator is used.</td></tr>
  </table>
</dl>
The most useful values for this are OP_OR (the default) and OP_AND. OP_NEAR and OP_PHRASE can also be useful.<p>
So for example, 'weather forecast' is parsed as if it were 'weather OR forecast' by default. 
</div>
</div><p>
<a class="anchor" name="7651d48cdc661c0605c475925170cc71"></a><!-- doxytag: member="Xapian::QueryParser::set_max_wildcard_expansion" ref="7651d48cdc661c0605c475925170cc71" args="(Xapian::termcount limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_max_wildcard_expansion           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&nbsp;</td>
          <td class="paramname"> <em>limit</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify the maximum expansion of a wildcard term. 
<p>
Note: you must also set FLAG_WILDCARD for wildcard expansion to happen.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>The maximum number of terms each wildcard in the query can expand to, or 0 for no limit (which is the default). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2312c9865a58cc1149fe7cda9f0c2585"></a><!-- doxytag: member="Xapian::QueryParser::set_stemmer" ref="2312c9865a58cc1149fe7cda9f0c2585" args="(const Xapian::Stem &amp;stemmer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemmer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stemmer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the stemmer. 
<p>
This sets the stemming algorithm which will be used by the query parser. Note that the stemming algorithm will only be used according to the stemming strategy set by <a class="el" href="classXapian_1_1QueryParser.html#c7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy.">set_stemming_strategy()</a>, which defaults to STEM_NONE. Therefore, to use a stemming algorithm, you will also need to call <a class="el" href="classXapian_1_1QueryParser.html#c7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy.">set_stemming_strategy()</a> with a value other than STEM_NONE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stemmer</em>&nbsp;</td><td>The <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm.">Xapian::Stem</a> object to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c7dc3b55b6083bd3ff98fc8b2726c8fd"></a><!-- doxytag: member="Xapian::QueryParser::set_stemming_strategy" ref="c7dc3b55b6083bd3ff98fc8b2726c8fd" args="(stem_strategy strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemming_strategy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1QueryParser.html#e2959f7a1c5680f3fd1421d92445e220">stem_strategy</a>&nbsp;</td>
          <td class="paramname"> <em>strategy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the stemming strategy. 
<p>
This controls how the query parser will apply the stemming algorithm. Note that the stemming algorithm is only applied to words in probabilistic fields - boolean filter terms are never stemmed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>strategy</em>&nbsp;</td><td>The strategy to use - possible values are:<ul>
<li>STEM_NONE: Don't perform any stemming. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> &lt;= 1.3.0)</li><li>STEM_SOME: Search for stemmed forms of terms except for those which start with a capital letter, or are followed by certain characters (currently: (/@&lt;&gt;=*[{" ), or are used with operators which need positional information. Stemmed terms are prefixed with 'Z'. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> &gt;= 1.3.1)</li><li>STEM_ALL: Search for stemmed forms of all words (note: no 'Z' prefix is added).</li><li>STEM_ALL_Z: Search for stemmed forms of all words (note: 'Z' prefix is added). (new in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.2.11 and 1.3.1) </li></ul>
</td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b1046610676f72ba564108f0df5d77ab"></a><!-- doxytag: member="Xapian::QueryParser::set_stopper" ref="b1046610676f72ba564108f0df5d77ab" args="(const Stopper *stop=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stopper           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *&nbsp;</td>
          <td class="paramname"> <em>stop</em> = <code>NULL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the stopper. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stop</em>&nbsp;</td><td>The <a class="el" href="classXapian_1_1Stopper.html" title="Base class for stop-word decision functor.">Stopper</a> object to set (default NULL, which means no stopwords). </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="queryparser_8h.html">queryparser.h</a></ul>
</div>
<hr>
<address><small>
Documentation for Xapian (version 1.2.13).<br>
Generated on 9 Jan 2013 by
<a href="http://www.doxygen.org/">Doxygen 1.5.9</a>.
</small></address>
</body>
</html>
