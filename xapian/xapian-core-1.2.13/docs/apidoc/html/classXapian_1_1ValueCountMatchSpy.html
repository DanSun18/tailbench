<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: xapian-core: Xapian::ValueCountMatchSpy Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceXapian.html">Xapian</a>::<a class="el" href="classXapian_1_1ValueCountMatchSpy.html">ValueCountMatchSpy</a>
  </div>
</div>
<div class="contents">
<h1>Xapian::ValueCountMatchSpy Class Reference</h1><!-- doxytag: class="Xapian::ValueCountMatchSpy" --><!-- doxytag: inherits="Xapian::MatchSpy" -->Class for counting the frequencies of values in the matching documents.  
<a href="#_details">More...</a>
<p>
<div class="dynheader">
Inheritance diagram for Xapian::ValueCountMatchSpy:</div>
<div class="dynsection">
<p><center><img src="classXapian_1_1ValueCountMatchSpy__inherit__graph.png" border="0" usemap="#Xapian_1_1ValueCountMatchSpy__inherit__map" alt="Inheritance graph"></center>
<map name="Xapian_1_1ValueCountMatchSpy__inherit__map">
<area shape="rect" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies." alt="" coords="41,7,177,33"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classXapian_1_1ValueCountMatchSpy-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="be9390bb136f7c380126dc89c463795d"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::ValueCountMatchSpy" ref="be9390bb136f7c380126dc89c463795d" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#be9390bb136f7c380126dc89c463795d">ValueCountMatchSpy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty <a class="el" href="classXapian_1_1ValueCountMatchSpy.html" title="Class for counting the frequencies of values in the matching documents.">ValueCountMatchSpy</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1cb660b864dfa6d72cffbe587f5a8b6"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::ValueCountMatchSpy" ref="d1cb660b864dfa6d72cffbe587f5a8b6" args="(Xapian::valueno slot_)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#d1cb660b864dfa6d72cffbe587f5a8b6">ValueCountMatchSpy</a> (<a class="el" href="namespaceXapian.html#94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> slot_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies.">MatchSpy</a> which counts the values in a particular slot. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#842576241bf5d4e38c84b8ac5272d3da">get_total</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total number of documents tallied.  <a href="#842576241bf5d4e38c84b8ac5272d3da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#91db513ea45da7adf5ff25c4706ab9b0">values_begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the values seen in the slot.  <a href="#91db513ea45da7adf5ff25c4706ab9b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34a09b5055c1953f28f6426769d0de2c"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::values_end" ref="34a09b5055c1953f28f6426769d0de2c" args="() const " -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#34a09b5055c1953f28f6426769d0de2c">values_end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1ValueCountMatchSpy.html#91db513ea45da7adf5ff25c4706ab9b0" title="Get an iterator over the values seen in the slot.">values_begin()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#2d433c9f883bdfa98fd1d56b7a972a3f">top_values_begin</a> (size_t maxvalues) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the most frequent values seen in the slot.  <a href="#2d433c9f883bdfa98fd1d56b7a972a3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2722e0f8735f696bd130f18069b394b6"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::top_values_end" ref="2722e0f8735f696bd130f18069b394b6" args="(size_t) const " -->
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#2722e0f8735f696bd130f18069b394b6">top_values_end</a> (size_t) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1ValueCountMatchSpy.html#2d433c9f883bdfa98fd1d56b7a972a3f" title="Get an iterator over the most frequent values seen in the slot.">top_values_begin()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#ba74fcbd87fa4a173d7cc6b7a26567d4">operator()</a> (const <a class="el" href="classXapian_1_1Document.html">Xapian::Document</a> &amp;doc, <a class="el" href="namespaceXapian.html#cac12803afc9e24ee5141c119acb8884">Xapian::weight</a> wt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of virtual operator().  <a href="#ba74fcbd87fa4a173d7cc6b7a26567d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#2f3f76f7a269b15b22e5f266a166ed00">clone</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clone the match spy.  <a href="#2f3f76f7a269b15b22e5f266a166ed00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#0156235fbae335975efe173cad85ea0a">name</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the name of this match spy.  <a href="#0156235fbae335975efe173cad85ea0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#4b0b12f88a83fa854160d62d3f0b1a66">serialise</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return this object's parameters serialised as a single string.  <a href="#4b0b12f88a83fa854160d62d3f0b1a66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#00c8fb9751f52c6f4a6610e23b130690">unserialise</a> (const std::string &amp;s, const <a class="el" href="classXapian_1_1Registry.html">Registry</a> &amp;context) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unserialise parameters.  <a href="#00c8fb9751f52c6f4a6610e23b130690"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#bf75525e101f358d07750abc466115da">serialise_results</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialise the results of this match spy.  <a href="#bf75525e101f358d07750abc466115da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#cc26d27271e945dc555c8f981b4fe775">merge_results</a> (const std::string &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unserialise some results, and merge them into this matchspy.  <a href="#cc26d27271e945dc555c8f981b4fe775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#350eb6f93aa5e01845a56f2fd30391f8">get_description</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing this object.  <a href="#350eb6f93aa5e01845a56f2fd30391f8"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Class for counting the frequencies of values in the matching documents. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2f3f76f7a269b15b22e5f266a166ed00"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::clone" ref="2f3f76f7a269b15b22e5f266a166ed00" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a>* Xapian::ValueCountMatchSpy::clone           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clone the match spy. 
<p>
The clone should inherit the configuration of the parent, but need not inherit the state. ie, the clone does not need to be passed information about the results seen by the parent.<p>
If you don't want to support the remote backend in your match spy, you can use the default implementation which simply throws <a class="el" href="classXapian_1_1UnimplementedError.html" title="UnimplementedError indicates an attempt to use an unimplemented feature.">Xapian::UnimplementedError</a>.<p>
Note that the returned object will be deallocated by <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> after use with "delete". If you want to handle the deletion in a special way (for example when wrapping the <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> API for use from another language) then you can define a static <code>operator delete</code> method in your subclass as shown here: <a href="http://trac.xapian.org/ticket/554#comment:1">http://trac.xapian.org/ticket/554#comment:1</a> 
<p>Reimplemented from <a class="el" href="classXapian_1_1MatchSpy.html#d172b16efde32cf0dcbb0fb6fb43dc33">Xapian::MatchSpy</a>.</p>

</div>
</div><p>
<a class="anchor" name="350eb6f93aa5e01845a56f2fd30391f8"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::get_description" ref="350eb6f93aa5e01845a56f2fd30391f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Xapian::ValueCountMatchSpy::get_description           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a string describing this object. 
<p>
This default implementation returns a generic answer, to avoid forcing those deriving their own <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies.">MatchSpy</a> subclasses from having to implement this (they may not care what <a class="el" href="classXapian_1_1ValueCountMatchSpy.html#350eb6f93aa5e01845a56f2fd30391f8" title="Return a string describing this object.">get_description()</a> gives for their subclass). 
<p>Reimplemented from <a class="el" href="classXapian_1_1MatchSpy.html#b12e942f6657c86938cb83a55febc4e2">Xapian::MatchSpy</a>.</p>

</div>
</div><p>
<a class="anchor" name="842576241bf5d4e38c84b8ac5272d3da"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::get_total" ref="842576241bf5d4e38c84b8ac5272d3da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Xapian::ValueCountMatchSpy::get_total           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the total number of documents tallied. 
<p>

</div>
</div><p>
<a class="anchor" name="cc26d27271e945dc555c8f981b4fe775"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::merge_results" ref="cc26d27271e945dc555c8f981b4fe775" args="(const std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Xapian::ValueCountMatchSpy::merge_results           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unserialise some results, and merge them into this matchspy. 
<p>
The order in which results are merged should not be significant, since this order is not specified (and will vary depending on the speed of the search in each sub-database).<p>
If you don't want to support the remote backend in your match spy, you can use the default implementation which simply throws <a class="el" href="classXapian_1_1UnimplementedError.html" title="UnimplementedError indicates an attempt to use an unimplemented feature.">Xapian::UnimplementedError</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A string containing the serialised results. </td></tr>
  </table>
</dl>

<p>Reimplemented from <a class="el" href="classXapian_1_1MatchSpy.html#921014b484002f909cd9649477e25c81">Xapian::MatchSpy</a>.</p>

</div>
</div><p>
<a class="anchor" name="0156235fbae335975efe173cad85ea0a"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::name" ref="0156235fbae335975efe173cad85ea0a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Xapian::ValueCountMatchSpy::name           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the name of this match spy. 
<p>
This name is used by the remote backend. It is passed with the serialised parameters to the remote server so that it knows which class to create.<p>
Return the full namespace-qualified name of your class here - if your class is called MyApp::FooMatchSpy, return "MyApp::FooMatchSpy" from this method.<p>
If you don't want to support the remote backend in your match spy, you can use the default implementation which simply throws <a class="el" href="classXapian_1_1UnimplementedError.html" title="UnimplementedError indicates an attempt to use an unimplemented feature.">Xapian::UnimplementedError</a>. 
<p>Reimplemented from <a class="el" href="classXapian_1_1MatchSpy.html#4f7e79243aed9b81fba8a6c7f9500f0f">Xapian::MatchSpy</a>.</p>

</div>
</div><p>
<a class="anchor" name="ba74fcbd87fa4a173d7cc6b7a26567d4"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::operator()" ref="ba74fcbd87fa4a173d7cc6b7a26567d4" args="(const Xapian::Document &amp;doc, Xapian::weight wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::ValueCountMatchSpy::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Document.html">Xapian::Document</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#cac12803afc9e24ee5141c119acb8884">Xapian::weight</a>&nbsp;</td>
          <td class="paramname"> <em>wt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Implementation of virtual operator(). 
<p>
This implementation tallies values for a matching document.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>doc</em>&nbsp;</td><td>The document to tally values for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wt</em>&nbsp;</td><td>The weight of the document (ignored by this class). </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classXapian_1_1MatchSpy.html#1d4a22970c8042a0bd697b473625f9bf">Xapian::MatchSpy</a>.</p>

</div>
</div><p>
<a class="anchor" name="4b0b12f88a83fa854160d62d3f0b1a66"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::serialise" ref="4b0b12f88a83fa854160d62d3f0b1a66" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Xapian::ValueCountMatchSpy::serialise           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return this object's parameters serialised as a single string. 
<p>
If you don't want to support the remote backend in your match spy, you can use the default implementation which simply throws <a class="el" href="classXapian_1_1UnimplementedError.html" title="UnimplementedError indicates an attempt to use an unimplemented feature.">Xapian::UnimplementedError</a>. 
<p>Reimplemented from <a class="el" href="classXapian_1_1MatchSpy.html#59b3e4c181f9dc78e78609949ffe6ec7">Xapian::MatchSpy</a>.</p>

</div>
</div><p>
<a class="anchor" name="bf75525e101f358d07750abc466115da"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::serialise_results" ref="bf75525e101f358d07750abc466115da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Xapian::ValueCountMatchSpy::serialise_results           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Serialise the results of this match spy. 
<p>
If you don't want to support the remote backend in your match spy, you can use the default implementation which simply throws <a class="el" href="classXapian_1_1UnimplementedError.html" title="UnimplementedError indicates an attempt to use an unimplemented feature.">Xapian::UnimplementedError</a>. 
<p>Reimplemented from <a class="el" href="classXapian_1_1MatchSpy.html#3892fcdd67c425ff1ba493e2ac397ce9">Xapian::MatchSpy</a>.</p>

</div>
</div><p>
<a class="anchor" name="2d433c9f883bdfa98fd1d56b7a972a3f"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::top_values_begin" ref="2d433c9f883bdfa98fd1d56b7a972a3f" args="(size_t maxvalues) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::ValueCountMatchSpy::top_values_begin           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>maxvalues</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the most frequent values seen in the slot. 
<p>
Items will be returned in descending order of frequency. Values with the same frequency will be returned in ascending alphabetical order.<p>
During the iteration, the frequency of the current value can be obtained with the get_termfreq() method on the iterator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxvalues</em>&nbsp;</td><td>The maximum number of values to return. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="00c8fb9751f52c6f4a6610e23b130690"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::unserialise" ref="00c8fb9751f52c6f4a6610e23b130690" args="(const std::string &amp;s, const Registry &amp;context) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a>* Xapian::ValueCountMatchSpy::unserialise           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Registry.html">Registry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unserialise parameters. 
<p>
This method unserialises parameters serialised by the <em><a class="el" href="classXapian_1_1ValueCountMatchSpy.html#4b0b12f88a83fa854160d62d3f0b1a66" title="Return this object&#39;s parameters serialised as a single string.">serialise()</a></em> method and allocates and returns a new object initialised with them.<p>
If you don't want to support the remote backend in your match spy, you can use the default implementation which simply throws <a class="el" href="classXapian_1_1UnimplementedError.html" title="UnimplementedError indicates an attempt to use an unimplemented feature.">Xapian::UnimplementedError</a>.<p>
Note that the returned object will be deallocated by <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> after use with "delete". If you want to handle the deletion in a special way (for example when wrapping the <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> API for use from another language) then you can define a static <code>operator delete</code> method in your subclass as shown here: <a href="http://trac.xapian.org/ticket/554#comment:1">http://trac.xapian.org/ticket/554#comment:1</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>A string containing the serialised results. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td><a class="el" href="classXapian_1_1Registry.html" title="Registry for user subclasses.">Registry</a> object to use for unserialisation to permit <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies.">MatchSpy</a> subclasses with sub-MatchSpy objects to be implemented. </td></tr>
  </table>
</dl>

<p>Reimplemented from <a class="el" href="classXapian_1_1MatchSpy.html#8ddda381134be9b9d973e746753ad3e2">Xapian::MatchSpy</a>.</p>

</div>
</div><p>
<a class="anchor" name="91db513ea45da7adf5ff25c4706ab9b0"></a><!-- doxytag: member="Xapian::ValueCountMatchSpy::values_begin" ref="91db513ea45da7adf5ff25c4706ab9b0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::ValueCountMatchSpy::values_begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the values seen in the slot. 
<p>
Items will be returned in ascending alphabetical order.<p>
During the iteration, the frequency of the current value can be obtained with the get_termfreq() method on the iterator. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="matchspy_8h.html">matchspy.h</a></ul>
</div>
<hr>
<address><small>
Documentation for Xapian (version 1.2.13).<br>
Generated on 9 Jan 2013 by
<a href="http://www.doxygen.org/">Doxygen 1.5.9</a>.
</small></address>
</body>
</html>
